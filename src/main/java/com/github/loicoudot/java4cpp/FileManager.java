package com.github.loicoudot.java4cpp;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Formatter;
import java.util.List;
import java.util.Properties;

/**
 * Manager for all interractions between java4cpp and the file system.
 * <p>
 * There are two log files:
 * <ul>
 * <li>{@code java4cpp.log} inside the target directory along the C++ proxies,
 * which contains the dependency tree of class.</li>
 * <li>maven plugin log, for logging informations and errors to the console.</li>
 * </ul>
 * Other file are the C++ proxies, and {@code java4cpp.hash} also inside the
 * target directory, which contains the MD5 hash value of the files.
 * 
 * @author Loic Oudot
 * 
 */
final class FileManager {
    private static final String JAVA4CPP_HASH = "java4cpp.hash";
    private static final String JAVA4CPP_LOG = "java4cpp.log";
    private static final int BUFFER_SIZE = 1024;
    private final Context context;
    private FileWriter java4cppLog;
    private File java4cppHash;
    private List<File> oldFiles = new ArrayList<File>();
    private final Properties oldHashes = new Properties();
    private final Properties newHashes = new Properties();
    private int generated;
    private int skipped;
    private int deleted;

    /**
     * A {@code FilenameFilter} to filter files other than {@code java4cpp.log}
     * and {@code java4cpp.hash}
     * 
     * @author Loic Oudot
     * 
     */
    final class SourceFilter implements FilenameFilter {
        @Override
        public boolean accept(File dir, String name) {
            return !name.equalsIgnoreCase(FileManager.JAVA4CPP_LOG) && name.equalsIgnoreCase(FileManager.JAVA4CPP_HASH);
        }
    }

    public FileManager(Context context) {
        this.context = context;
    }

    /**
     * Called before starting generating proxies files. Create the
     * {@code java4cpp.log} log file, and manage the {@code clean} and
     * {@code useHash} settings.
     */
    public void start() {
        try {
            java4cppLog = new FileWriter(new File(getPath(JAVA4CPP_LOG)));
        } catch (IOException e) {
            System.err.println("Can't create log file: " + e.getMessage());
        }
        try {
            File rep = new File(context.getSettings().getTargetPath());
            rep.mkdirs();
            File[] existings = rep.listFiles(new SourceFilter());
            if (existings != null) {
                oldFiles = new ArrayList<File>(Arrays.asList(existings));
            }
            java4cppHash = new File(getPath(JAVA4CPP_HASH));
            BufferedInputStream in = new BufferedInputStream(new FileInputStream(java4cppHash));
            oldHashes.load(in);
            in.close();
            java4cppHash.delete();
        } catch (IOException e) {
            logInfo("no java4cpp.hash file, regenerating all files");
        }
    }

    /**
     * Called after all the proxies are generated. Delete all the remaining
     * files in the target directory.
     */
    public void stop() {
        if (context.getSettings().isClean()) {
            for (File file : oldFiles) {
                logInfo("deleting " + file.getName());
                if (!file.delete()) {
                    logInfo("failed");
                }
                ++deleted;
            }
        }
        try {
            final BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(java4cppHash));
            newHashes.store(out, "Generated by java4cpp");
            out.close();
        } catch (IOException e) {
            throw new RuntimeException("Failed to generate java4cpp.hash " + e.getMessage());
        }
        logInfo(String.format("generated: %d, skipped: %d, deleted: %d", generated, skipped, deleted));
    }

    /**
     * Write {@code message} inside the {@code java4cpp.log} file.
     * 
     * @param message
     *            the message to log
     */
    public void logInfo(String message) {
        synchronized (java4cppLog) {
            try {
                java4cppLog.append('[').append(Thread.currentThread().getName()).append("] ");
                java4cppLog.append(message).append('\n');
                java4cppLog.flush();
            } catch (IOException e) {
            }
        }
    }

    public void writeSourceFile(String fileName, StringWriter sw) {
        saveFile(new String(sw.getBuffer()), new File(getPath(fileName)));
    }

    public void copyFile(String fileName) throws IOException {
        String content = readFile(Utils.getFileOrResource(fileName));
        saveFile(content, new File(getPath(fileName)));
    }

    /**
     * Write the file {@code fileName} in the target directory with
     * {@code fileContent}. If {@code useHash} is true, then the file is save if
     * it's doesn't exist or if the content has changed.
     * 
     * @param fileName
     * @param sw
     */
    private synchronized void saveFile(String fileContent, File fileName) {
        try {
            MessageDigest algo = MessageDigest.getInstance("MD5");
            algo.update(fileContent.getBytes());
            String md5 = bytesToHexString(algo.digest());
            newHashes.put(fileName.getName(), md5);

            if (!oldFiles.contains(fileName) || !md5.equals(oldHashes.getProperty(fileName.getName()))) {
                fileName.setWritable(true);
                BufferedOutputStream writer = new BufferedOutputStream(new FileOutputStream(fileName));
                writer.write(fileContent.getBytes());
                fileName.setWritable(false);
                writer.close();
                ++generated;
                logInfo("   generated " + fileName);
            } else {
                ++skipped;
                logInfo("   skipped " + fileName);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to save file " + e.getMessage());
        }
        oldFiles.remove(fileName);
    }

    private String getPath(String fileName) {
        return String.format("%s%s%s", context.getSettings().getTargetPath(), File.separator, fileName);
    }

    private String readFile(InputStream input) throws IOException {
        Appendable sb = new StringBuilder(BUFFER_SIZE);
        Reader reader = new InputStreamReader(input);

        char[] chars = new char[BUFFER_SIZE];
        int numRead;
        while ((numRead = reader.read(chars)) > -1) {
            sb.append(String.valueOf(chars, 0, numRead));
        }
        reader.close();
        return sb.toString();
    }

    private static String bytesToHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 2);

        Formatter formatter = new Formatter(sb);
        for (byte b : bytes) {
            formatter.format("%02X", b);
        }
        formatter.close();

        return sb.toString();
    }
}
