package com.github.loicoudot.java4cpp;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Formatter;
import java.util.List;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

final class SourceFilter implements FilenameFilter {
    @Override
    public boolean accept(File dir, String name) {
        return (name.endsWith(".cpp") || name.endsWith(".h"));
    }
}

public final class FileManager {
    private final Logger log = LoggerFactory.getLogger(FileManager.class);
    private static final String JAVA4CPP_HASH = "java4cpp.hash";
    private static final int BUFFER_SIZE = 1024;
    private final Context context;
    private File java4cppHash;
    private List<File> oldFiles = new ArrayList<File>();
    private final Properties oldHashes = new Properties();
    private final Properties newHashes = new Properties();
    private int generated;
    private int skipped;
    private int deleted;

    public FileManager(Context context) {
        this.context = context;
    }

    public void start() {
        try {
            File rep = new File(context.getSettings().getTargetPath());
            rep.mkdirs();
            File[] existings = rep.listFiles(new SourceFilter());
            if (existings != null) {
                oldFiles = new ArrayList<File>(Arrays.asList(existings));
            }
            java4cppHash = new File(getPath(JAVA4CPP_HASH));
            BufferedInputStream in = new BufferedInputStream(new FileInputStream(java4cppHash));
            oldHashes.load(in);
            java4cppHash.delete();
            in.close();
        } catch (IOException e) {
            log.info("no java4cpp.hash file, regenerating all files");
        }
    }

    public void stop() {
        if (context.getSettings().isClean()) {
            for (File file : oldFiles) {
                log.info("deleting {}", file.getName());
                if (!file.delete()) {
                    log.info("failed");
                }
                ++deleted;
            }
        }
        try {
            final BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(java4cppHash));
            newHashes.store(out, "Generated by java4cpp");
            out.close();
        } catch (IOException e) {
            log.info("Error while generating java4cpp.hash");
        }
        log.info(String.format("generated: %d, skipped: %d, deleted: %d", generated, skipped, deleted));
    }

    public void writeSourceFile(String fileName, StringWriter sw) {
        saveFile(new String(sw.getBuffer()), new File(getPath(fileName)));
    }

    public void copyFile(String fileName) throws IOException {
        String content = readFile(Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName));
        saveFile(content, new File(getPath(fileName)));
    }

    private synchronized void saveFile(String fileContent, File fileName) {
        try {
            MessageDigest algo = MessageDigest.getInstance("MD5");
            algo.update(fileContent.getBytes());
            String md5 = bytesToHexString(algo.digest());
            newHashes.put(fileName.getName(), md5);

            if (!oldFiles.contains(fileName) || !md5.equals(oldHashes.getProperty(fileName.getName()))) {
                fileName.setWritable(true);
                BufferedOutputStream writer = new BufferedOutputStream(new FileOutputStream(fileName));
                writer.write(fileContent.getBytes());
                fileName.setWritable(false);
                writer.close();
                ++generated;
                log.info("   generated {}", fileName);
            } else {
                ++skipped;
                log.info("   skipped {}", fileName);
            }
        } catch (IOException e) {
            log.info(e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            log.info(e.getMessage());
        }
        oldFiles.remove(fileName);
    }

    private String getPath(String fileName) {
        return String.format("%s%s%s", context.getSettings().getTargetPath(), File.separator, fileName);
    }

    private String readFile(InputStream input) throws IOException {
        Appendable sb = new StringBuilder(BUFFER_SIZE);
        Reader reader = new InputStreamReader(input);

        char[] chars = new char[BUFFER_SIZE];
        int numRead;
        while ((numRead = reader.read(chars)) > -1) {
            sb.append(String.valueOf(chars, 0, numRead));
        }
        reader.close();
        return sb.toString();
    }

    private static String bytesToHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 2);

        Formatter formatter = new Formatter(sb);
        for (byte b : bytes) {
            formatter.format("%02X", b);
        }
        formatter.close();

        return sb.toString();
    }
}
